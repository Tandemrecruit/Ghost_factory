import { notFound } from 'next/navigation'
import fs from 'fs'
import path from 'path'
import { isValidClientId } from '@/lib/client-utils'

interface ClientPageProps {
  params: Promise<{
    clientId: string
  }>
}

export default async function ClientPage({ params }: ClientPageProps) {
  const { clientId } = await params

  // Validate client ID to prevent path traversal attacks
  if (!isValidClientId(clientId)) {
    notFound()
  }

  // This is a placeholder route that will be overwritten by the factory
  // when it generates actual client pages. The factory outputs directly
  // to app/clients/{clientId}/page.tsx

  // Check if this is a valid client directory
  const clientDir = path.join(process.cwd(), 'clients', clientId)
  const hasClientData = fs.existsSync(clientDir)

  if (!hasClientData) {
    notFound()
  }

  return (
    <main className="flex min-h-screen flex-col items-center justify-center px-4">
      <div className="text-center">
        <h1 className="mb-4 text-2xl font-bold">
          Client: {clientId}
        </h1>
        <p className="text-muted-foreground">
          This page will be generated by the Ghost Factory automation pipeline.
        </p>
        <p className="mt-4 text-sm text-muted-foreground">
          Add an <code className="rounded bg-muted px-2 py-1">intake.md</code> file to{' '}
          <code className="rounded bg-muted px-2 py-1">clients/{clientId}/</code> to trigger generation.
        </p>
      </div>
    </main>
  )
}

export async function generateStaticParams() {
  // This can be used to pre-generate pages for known clients
  const clientsDir = path.join(process.cwd(), 'clients')

  if (!fs.existsSync(clientsDir)) {
    return []
  }

  const clients = fs.readdirSync(clientsDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .filter(dirent => isValidClientId(dirent.name))
    .map(dirent => ({
      clientId: dirent.name,
    }))

  return clients
}
